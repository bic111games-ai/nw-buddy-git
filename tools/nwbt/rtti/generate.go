package rtti

import (
	"fmt"
	"nw-buddy/tools/rtti/nwt"
	"nw-buddy/tools/utils/str"
	"sort"
	"strings"
)

func (it *Type) getCleanName() string {
	if it.Name == "" {
		return "UUID_" + strings.ReplaceAll(it.ID, "-", "_")
	}
	return clean(it.Name)
}

func (it *Member) getCleanName() string {
	if it.Name == "" {
		return fmt.Sprintf("CRC_%v", it.Crc32)
	}
	return clean(it.Name)
}

func (it *Type) getElementTypeName(table TypeTable) string {
	if len(it.Members) != 1 {
		return ""
	}
	for _, member := range it.Members {
		if !strings.EqualFold(member.Name, "Element") {
			return ""
		}
		if len(member.TypeIDs) > 1 || member.TypeID == "" {
			// want only unique element type ID
			return ""
		}
		if !table.Has(member.TypeID) {
			return ""
		}
		return table[member.TypeID].getCleanName()
	}
	return ""
}

func (it TypeTable) GenerateCode() string {
	buildIndex := str.NewBuilder()
	buildTypes := str.NewBuilder()

	types := make([]*Type, 0, len(it))
	for _, t := range it {
		types = append(types, t)
	}
	sort.Slice(types, func(i, j int) bool {
		nameA := types[i].getCleanName()
		nameB := types[j].getCleanName()
		if nameA == nameB {
			return types[i].ID < types[j].ID
		}
		return nameA < nameB
	})

	tracker := make(map[string]int)
	typeNames := make(map[string]string)
	for ID, t := range nwt.PRIMITIVES {
		name := t.Name()
		typeNames[ID] = name
	}
	for _, t := range types {
		if _, ok := nwt.PRIMITIVES[t.ID]; ok {
			continue
		}

		name := t.getCleanName()
		if elementName := t.getElementTypeName(it); elementName != "" {
			name = strings.TrimRight(name, "_") + "_" + elementName
		}
		// add counter suffix to avoid collisions
		if count, ok := tracker[name]; ok {
			tracker[name] = count + 1
			name = fmt.Sprintf("%v_%v", name, count)
		} else {
			tracker[name] = 0
		}
		typeNames[t.ID] = name
	}

	for _, t := range types {
		if _, ok := nwt.PRIMITIVES[t.ID]; ok {
			// skip predefined primitive types
			continue
		}

		name := typeNames[t.ID]
		buildIndex.Line("\t\"%s\": reflect.TypeOf(%s{}),", t.ID, name)

		members := make([]*Member, 0, len(t.Members))
		for _, m := range t.Members {
			members = append(members, m)
		}
		sort.Slice(members, func(i, j int) bool {
			return members[i].getCleanName() < members[j].getCleanName()
		})

		buildTypes.Line("")
		buildTypes.Line("type %v struct {", name)
		for _, m := range members {
			mt := it.GetOrCreate(m.TypeID)
			typeName := typeNames[mt.ID]
			if len(m.TypeIDs) > 0 || typeName == "" {
				typeName = "any"
			}
			if m.Array {
				typeName = "[]" + typeName
			}
			buildTypes.Line("\t%v %v `crc:\"%d\"`", m.getCleanName(), typeName, m.Crc32)
		}
		buildTypes.Line("}")
	}

	sb := str.NewBuilder()
	sb.Line("// Code generated by rtti.GenerateCode(); DO NOT EDIT.\n")
	sb.Line("package nwt\n")
	sb.Line("import \"reflect\"\n")
	sb.Line("var GENERATED = map[string]reflect.Type{\n%s}", buildIndex.String())
	sb.Append(buildTypes.String())

	return sb.String()
}

func clean(value string) string {
	s := []byte(value)
	for i, b := range s {
		if 'a' <= b && b <= 'z' {
			continue
		}
		if 'A' <= b && b <= 'Z' {
			continue
		}
		if b == '_' {
			continue
		}
		if i > 0 && '0' <= b && b <= '9' {
			continue
		}
		s[i] = '_'
	}

	// ensure leading character is a capital letter
	// to make it public
	if s[0] == '_' {
		return "Az" + string(s)
	}
	s[0] = strings.ToUpper(string(s[0]))[0]

	return string(s)
}
